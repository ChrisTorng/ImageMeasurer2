<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>照片變形校正工具</title>
    <script
      async
      src="https://docs.opencv.org/4.x/opencv.js"
      onload="onOpenCvReady();"
    ></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
        overflow: hidden;
      }
      canvas {
        border: 1px solid #ccc;
        margin: 10px auto;
        display: block;
        max-width: 100vw;
        max-height: 80vh;
      }
      button {
        padding: 10px 20px;
        margin: 5px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      #step1,
      #step2,
      #step3 {
        display: none;
      }
      #step1.active,
      #step2.active,
      #step3.active {
        display: block;
      }
      #uploadArea {
        border: 2px dashed #ccc;
        padding: 20px;
        margin: 20px auto;
        width: 80%;
        max-width: 600px;
      }
    </style>
  </head>
  <body>
    <div id="step1" class="active">
      <h1>照片變形校正工具</h1>
      <p>上傳一張照片，框選變形的四邊形區域，我們將自動校正為長方形。</p>
      <div id="uploadArea">拖放照片至此或點擊選擇文件</div>
      <input
        type="file"
        id="uploadPhoto"
        accept="image/*"
        style="display: none"
      />
    </div>

    <div id="step2">
      <h2>框選四邊形</h2>
      <p>拖曳四個頂點以框選照片中變形的長方形物體。</p>
      <canvas id="photoCanvas"></canvas>
      <button id="nextStep">下一步</button>
      <button id="exportStep2">匯出影像</button>
    </div>

    <div id="step3">
      <h2>校正結果</h2>
      <p>調整邊界以涵蓋完整內容，或返回上一步重新框選。</p>
      <canvas id="transformedCanvas"></canvas>
      <button id="previousStep">上一步</button>
      <button id="exportStep3">匯出影像</button>
    </div>

    <script>
      let originalImage = null;
      let points = [];
      let selectedPoint = null;
      let originalFileName = "";
      let scaleFactor = 1;

      async function onOpenCvReady() { window.cv = await window.cv }

      function showStep(step) {
        console.log(`Switching to step ${step}`);
        document.getElementById("step1").classList.remove("active");
        document.getElementById("step2").classList.remove("active");
        document.getElementById("step3").classList.remove("active");
        document.getElementById(`step${step}`).classList.add("active");
      }

      function handleFileUpload(file) {
        originalFileName = file.name.split(".").slice(0, -1).join(".");
        const reader = new FileReader();
        reader.onload = function (e) {
          const img = new Image();
          img.onload = function () {
            originalImage = img;
            setupStep2();
            showStep(2);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      }

      const uploadArea = document.getElementById("uploadArea");
      uploadArea.addEventListener("click", function () {
        document.getElementById("uploadPhoto").click();
      });
      uploadArea.addEventListener("dragover", function (e) {
        e.preventDefault();
        uploadArea.style.borderColor = "#007BFF";
      });
      uploadArea.addEventListener("drop", function (e) {
        e.preventDefault();
        uploadArea.style.borderColor = "#ccc";
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          handleFileUpload(file);
        }
      });
      document
        .getElementById("uploadPhoto")
        .addEventListener("change", function (event) {
          const file = event.target.files[0];
          if (file) {
            handleFileUpload(file);
          }
        });

      function setupStep2() {
        const canvas = document.getElementById("photoCanvas");
        const ctx = canvas.getContext("2d");

        const maxWidth = window.innerWidth * 0.9;
        const maxHeight = window.innerHeight * 0.7;
        scaleFactor = Math.min(
          maxWidth / originalImage.width,
          maxHeight / originalImage.height,
          1
        );
        canvas.width = originalImage.width * scaleFactor;
        canvas.height = originalImage.height * scaleFactor;

        points = [
          { x: canvas.width * 0.25, y: canvas.height * 0.25 },
          { x: canvas.width * 0.75, y: canvas.height * 0.25 },
          { x: canvas.width * 0.75, y: canvas.height * 0.75 },
          { x: canvas.width * 0.25, y: canvas.height * 0.75 },
        ];

        function drawQuadrilateral() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.closePath();
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.stroke();
          points.forEach((point) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "red";
            ctx.fill();
          });
        }

        drawQuadrilateral();

        canvas.addEventListener("mousedown", function (e) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          points.forEach((point, index) => {
            const dx = mouseX - point.x;
            const dy = mouseY - point.y;
            if (Math.sqrt(dx * dx + dy * dy) < 10) {
              selectedPoint = index;
            }
          });
        });

        canvas.addEventListener("mousemove", function (e) {
          if (selectedPoint !== null) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            points[selectedPoint].x = mouseX;
            points[selectedPoint].y = mouseY;
            drawQuadrilateral();
          }
        });

        canvas.addEventListener("mouseup", function () {
          selectedPoint = null;
        });

        document
          .getElementById("exportStep2")
          .addEventListener("click", function () {
            const dataURL = canvas.toDataURL("image/png");
            const link = document.createElement("a");
            link.href = dataURL;
            link.download = `${originalFileName}_step2.png`;
            link.click();
          });

        document
          .getElementById("nextStep")
          .addEventListener("click", function () {
            console.log("Proceeding to step 3");
            setupStep3();
            showStep(3);
          });
      }

      function setupStep3() {
        console.log("Setting up step 3");
        const canvas = document.getElementById("transformedCanvas");
        const ctx = canvas.getContext("2d");

        // 確認 cv 物件是否存在
        if (typeof cv === "undefined" || !cv.Mat) {
          console.error("OpenCV.js failed to load properly.");
          return;
        }

        function getLongestSide(points) {
          const distances = [];
          for (let i = 0; i < points.length; i++) {
            const next = (i + 1) % points.length;
            const dx = (points[next].x - points[i].x) / scaleFactor;
            const dy = (points[next].y - points[i].y) / scaleFactor;
            distances.push(Math.sqrt(dx * dx + dy * dy));
          }
          return Math.max(...distances);
        }

        const longestSide = getLongestSide(points);
        const targetWidth = longestSide;
        const targetHeight = (longestSide * 2) / 3; // 假設高寬比
        const targetPoints = [
          { x: 0, y: 0 },
          { x: targetWidth, y: 0 },
          { x: targetWidth, y: targetHeight },
          { x: 0, y: targetHeight },
        ];

        const originalPoints = points.map((point) => ({
          x: point.x / scaleFactor,
          y: point.y / scaleFactor,
        }));

        const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
          originalPoints[0].x,
          originalPoints[0].y,
          originalPoints[1].x,
          originalPoints[1].y,
          originalPoints[2].x,
          originalPoints[2].y,
          originalPoints[3].x,
          originalPoints[3].y,
        ]);
        const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
          targetPoints[0].x,
          targetPoints[0].y,
          targetPoints[1].x,
          targetPoints[1].y,
          targetPoints[2].x,
          targetPoints[2].y,
          targetPoints[3].x,
          targetPoints[3].y,
        ]);

        const transformMatrix = cv.getPerspectiveTransform(
          srcPoints,
          dstPoints
        );
        const src = cv.imread(originalImage);
        const dst = new cv.Mat();
        cv.warpPerspective(
          src,
          dst,
          transformMatrix,
          new cv.Size(targetWidth, targetHeight)
        );
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        cv.imshow(canvas, dst);

        src.delete();
        dst.delete();
        transformMatrix.delete();
        srcPoints.delete();
        dstPoints.delete();

        document
          .getElementById("previousStep")
          .addEventListener("click", function () {
            console.log("Going back to step 2");
            showStep(2);
          });

        document
          .getElementById("exportStep3")
          .addEventListener("click", function () {
            const dataURL = canvas.toDataURL("image/png");
            const link = document.createElement("a");
            link.href = dataURL;
            link.download = `${originalFileName}_transformed.png`;
            link.click();
          });
      }
    </script>
  </body>
</html>
