<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>照片變形校正工具</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        p {
            color: #666;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 10px auto;
            display: block;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #step1, #step2, #step3 {
            display: none;
        }
        #step1.active, #step2.active, #step3.active {
            display: block;
        }
        #uploadPhoto {
            margin: 20px;
        }
    </style>
</head>
<body>
    <!-- 第一步：首頁與照片上傳 -->
    <div id="step1" class="active">
        <h1>照片變形校正工具</h1>
        <p>上傳一張照片，框選變形的四邊形區域，我們將自動校正為長方形。</p>
        <input type="file" id="uploadPhoto" accept="image/*">
    </div>

    <!-- 第二步：框選四邊形 -->
    <div id="step2">
        <h2>框選四邊形</h2>
        <p>拖曳四個頂點以框選照片中變形的長方形物體。</p>
        <canvas id="photoCanvas"></canvas>
        <button id="nextStep">下一步</button>
        <button id="exportStep2">匯出影像</button>
    </div>

    <!-- 第三步：透視變換與調整 -->
    <div id="step3">
        <h2>校正結果</h2>
        <p>調整邊界以涵蓋完整內容，或返回上一步重新框選。</p>
        <canvas id="transformedCanvas"></canvas>
        <button id="previousStep">上一步</button>
        <button id="exportStep3">匯出影像</button>
    </div>

    <script>
        let originalImage = null;
        let points = [];
        let selectedPoint = null;
        let transformedImage = null;

        // 切換步驟
        function showStep(step) {
            document.getElementById("step1").classList.remove("active");
            document.getElementById("step2").classList.remove("active");
            document.getElementById("step3").classList.remove("active");
            document.getElementById(`step${step}`).classList.add("active");
        }

        // 第一步：上傳照片
        document.getElementById("uploadPhoto").addEventListener("change", function(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    setupStep2();
                    showStep(2);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // 第二步：設置畫布與框選功能
        function setupStep2() {
            const canvas = document.getElementById("photoCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // 初始化預設四邊形
            points = [
                { x: canvas.width * 0.25, y: canvas.height * 0.25 },
                { x: canvas.width * 0.75, y: canvas.height * 0.25 },
                { x: canvas.width * 0.75, y: canvas.height * 0.75 },
                { x: canvas.width * 0.25, y: canvas.height * 0.75 }
            ];

            function drawQuadrilateral() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(originalImage, 0, 0);
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.stroke();
                points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = "red";
                    ctx.fill();
                });
            }

            drawQuadrilateral();

            // 拖曳功能
            canvas.addEventListener("mousedown", function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                points.forEach((point, index) => {
                    const dx = mouseX - point.x;
                    const dy = mouseY - point.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 10) {
                        selectedPoint = index;
                    }
                });
            });

            canvas.addEventListener("mousemove", function(e) {
                if (selectedPoint !== null) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    points[selectedPoint].x = mouseX;
                    points[selectedPoint].y = mouseY;
                    drawQuadrilateral();
                }
            });

            canvas.addEventListener("mouseup", function() {
                selectedPoint = null;
            });

            // 匯出功能
            document.getElementById("exportStep2").addEventListener("click", function() {
                const dataURL = canvas.toDataURL("image/png");
                const link = document.createElement("a");
                link.href = dataURL;
                link.download = "step2_image.png";
                link.click();
            });

            // 下一步
            document.getElementById("nextStep").addEventListener("click", function() {
                setupStep3();
                showStep(3);
            });
        }

        // 第三步：透視變換與調整
        function setupStep3() {
            // 等待 OpenCV.js 加載完成
            if (typeof cv === "undefined" || !cv.Mat) {
                setTimeout(setupStep3, 100);
                return;
            }

            const canvas = document.getElementById("transformedCanvas");
            const ctx = canvas.getContext("2d");

            // 計算最長邊
            function getLongestSide(points) {
                const distances = [];
                for (let i = 0; i < points.length; i++) {
                    const next = (i + 1) % points.length;
                    const dx = points[next].x - points[i].x;
                    const dy = points[next].y - points[i].y;
                    distances.push(Math.sqrt(dx * dx + dy * dy));
                }
                return Math.max(...distances);
            }

            const longestSide = getLongestSide(points);
            const targetWidth = longestSide;
            const targetHeight = longestSide * 2 / 3; // 假設高寬比
            const targetPoints = [
                { x: 0, y: 0 },
                { x: targetWidth, y: 0 },
                { x: targetWidth, y: targetHeight },
                { x: 0, y: targetHeight }
            ];

            // 透視變換
            const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                points[0].x, points[0].y,
                points[1].x, points[1].y,
                points[2].x, points[2].y,
                points[3].x, points[3].y
            ]);
            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                targetPoints[0].x, targetPoints[0].y,
                targetPoints[1].x, targetPoints[1].y,
                targetPoints[2].x, targetPoints[2].y,
                targetPoints[3].x, targetPoints[3].y
            ]);

            const transformMatrix = cv.getPerspectiveTransform(srcPoints, dstPoints);
            const src = cv.imread(originalImage);
            const dst = new cv.Mat();
            cv.warpPerspective(src, dst, transformMatrix, new cv.Size(targetWidth, targetHeight));
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            cv.imshow(canvas, dst);

            src.delete();
            dst.delete();
            transformMatrix.delete();
            srcPoints.delete();
            dstPoints.delete();

            // 上一步
            document.getElementById("previousStep").addEventListener("click", function() {
                showStep(2);
            });

            // 匯出功能
            document.getElementById("exportStep3").addEventListener("click", function() {
                const dataURL = canvas.toDataURL("image/png");
                const link = document.createElement("a");
                link.href = dataURL;
                link.download = "step3_image.png";
                link.click();
            });
        }
    </script>
</body>
</html>